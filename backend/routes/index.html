<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas</title>
</head>
<style>
    .container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 95vh;
  }
  .drawing-area {
    box-shadow: 0 0 6px 0 #999;
  }
  .menu {
    position: relative;
}

.color-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    width: auto; /* Adjust this value as needed */
    white-space: nowrap; /* Prevent buttons from wrapping */
}

.color-menu.show {
    display: flex;
}

.color-button {
    background-color: transparent;
    border: none;
    color: #333;
    padding: 8px 16px;
    cursor: pointer;
    transition: color 0.3s;
}

.color-button:hover {
    color: #555;
}

.menu-button {
    background-color: transparent;
    border: none;
    color: #333;
    padding: 8px 16px;
    cursor: pointer;
    transition: color 0.3s;
}

.menu-button:hover {
    color: #555;
}
</style>
<body>
    <div class="container">
        <div class="menu">
            <button id="color-menu-button" class="menu-button" type="button">Color</button>
            <div id="color-menu" class="color-menu">
                <button id="black-color-button" class="color-button" type="button" onclick="changeStrokeColor('black')">Black</button>
                <button id="blue-color-button" class="color-button" type="button" onclick="changeStrokeColor('blue')">Blue</button>
                <button id="red-color-button" class="color-button" type="button" onclick="changeStrokeColor('red')">Red</button>
            </div>
        </div>
        <canvas id="drawing-area" class="drawing-area" height="800" width="600"></canvas>
        <div class="action" style="text-align: center;">
            <button id="clear-button" class="clear-button" type="button">Clear</button>
            <button id="save-button" class="save-button" type="button">Save</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('drawing-area');
const canvasContext = canvas.getContext('2d');
const clearButton = document.getElementById('clear-button');
const saveButton = document.getElementById('save-button');
const zoomButton = document.getElementById('zoom-button');
const state = {
    mousedown: false,
    points: []
};

// Get references to the color menu button and menu itself
const colorMenuButton = document.getElementById('color-menu-button');
const colorMenu = document.getElementById('color-menu');

// Function to toggle the visibility of the color menu
function toggleColorMenu() {
    colorMenu.classList.toggle('show');
}

// Function to hide the color menu
function hideColorMenu() {
    colorMenu.classList.remove('show');
}

// Event listener for the color menu button
colorMenuButton.addEventListener('click', toggleColorMenu);

// Get references to the color buttons
const blackColorButton = document.getElementById('black-color-button');
const blueColorButton = document.getElementById('blue-color-button');
const redColorButton = document.getElementById('red-color-button');

// Event listeners for the color buttons to hide the color menu when clicked
blackColorButton.addEventListener('click', hideColorMenu);
blueColorButton.addEventListener('click', hideColorMenu);
redColorButton.addEventListener('click', hideColorMenu);

let strokeColor = 'black';


// Function to change stroke color
function changeStrokeColor(color) {
    strokeColor = color;
}



const drName = "Dr. Sumit Bhadwa"
const QueNo ="29";
const pfNum="210412";
const pName="SNEHA";
const regNum="12H23";
const regDate="1/2/2003";
const drName_txt = `Name : ${drName}`;
const QueNo_txt = `Que No. : ${QueNo}`;
const pfNum_txt = `pf no. : ${pfNum}`;
const pName_txt = `patient Name: ${pName}`;
const regNum_txt=`reg num. : ${regNum}`;
const regDate_txt = `reg Date : ${regDate}`;
function drawText(){
    canvasContext.shadowColor="#000";
    canvasContext.font = "14px Arial";
    canvasContext.fillStyle = "#000";
    canvasContext.textBaseline = "middle";
    canvasContext.fillText(drName_txt, 100, 120);
    canvasContext.fillText(QueNo_txt,400,120);
    canvasContext.fillText(pfNum_txt,100,140);
    canvasContext.fillText(pName_txt,400,140);
    canvasContext.fillText(regNum_txt,100,160);
    canvasContext.fillText(regDate_txt,400,160);
}



// Call the drawText function


const defaultImage = () => {
    var backgroundImage = new Image();
    backgroundImage.onload = function() {
        canvasContext.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        drawText();
    };
    backgroundImage.src = './bg.png';
    
}

document.addEventListener("DOMContentLoaded", defaultImage);

const lineWidth = 0.4; // Adjusted for a thinner pen-like stroke
// const strokeStyle = 'black'; // Pen stroke color
// const shadowColor ='#000';
const shadowBlur =0.7;

canvas.addEventListener('mousedown', handleWritingStart);
canvas.addEventListener('mousemove', handleWritingInProgress);
canvas.addEventListener('mouseup', handleDrawingEnd);
canvas.addEventListener('mouseout', handleDrawingEnd);

canvas.addEventListener('touchstart', handleWritingStart);
canvas.addEventListener('touchmove', handleWritingInProgress);
canvas.addEventListener('touchend', handleDrawingEnd);

clearButton.addEventListener('click', handleClearButtonClick);
saveButton.addEventListener('click', handleSaveButtonClick);
zoomButton.addEventListener('click',handleZoomButtonClick);


function handleWritingStart(event) {
    event.preventDefault();
    const mousePos = getMosuePositionOnCanvas(event);
    state.points.push({ x: mousePos.x, y: mousePos.y });
    state.mousedown = true;
}

function handleWritingInProgress(event) {
    event.preventDefault();
    if (state.mousedown) {
        const mousePos = getMosuePositionOnCanvas(event);
        state.points.push({ x: mousePos.x, y: mousePos.y });
        drawSmoothLine();
    }
}

function handleDrawingEnd(event) {
    event.preventDefault();
    state.mousedown = false;
    state.points = [];
}

function handleClearButtonClick(event) {
    event.preventDefault();
    canvasContext.clearRect(0, 0, canvas.width, canvas.height);
    defaultImage();
}

// function handleSaveButtonClick(event) {
//     event.preventDefault();
//     const image = canvas.toDataURL("image/png");
//     const link = document.createElement("a");
//     link.href = image;
//     link.download = "canvas_image.png";
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }

function handleSaveButtonClick(event) {
    event.preventDefault();
    console.log("me call hua hu");
    const image = canvas.toDataURL("image/png");

    fetch('/api/v1/users/changeRecord', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ image: image })
    })
    .then(response => {
        if (response.ok) {
            console.log('Image uploaded successfully');
            // You can perform any additional actions here after successful upload
        } else {
            throw new Error('Failed to upload image');
        }
    })
    .catch(error => {
        console.error('Error uploading image:', error);
        // Handle error, show error message, etc.
    });
}



function getMosuePositionOnCanvas(event) {
    const clientX = event.clientX || event.touches[0].clientX;
    const clientY = event.clientY || event.touches[0].clientY;
    const { offsetLeft, offsetTop } = event.target;
    const canvasX = clientX - offsetLeft;
    const canvasY = clientY - offsetTop+window.scrollY;;
    return { x: canvasX, y: canvasY };
}

function drawSmoothLine() {
    if (state.points.length < 2) return;

    canvasContext.beginPath();
    canvasContext.moveTo(state.points[0].x, state.points[0].y);
    canvasContext.shadowColor=strokeColor;
    canvasContext.shadowBlur=shadowBlur;

    for (let i = 1; i < state.points.length - 2; i++) {
        const xc = (state.points[i].x + state.points[i + 1].x) / 2;
        const yc = (state.points[i].y + state.points[i + 1].y) / 2;
        canvasContext.quadraticCurveTo(state.points[i].x, state.points[i].y, xc, yc);
    }

    canvasContext.quadraticCurveTo(
        state.points[state.points.length - 2].x,
        state.points[state.points.length - 2].y,
        state.points[state.points.length - 1].x,
        state.points[state.points.length - 1].y
    );

    canvasContext.lineWidth = lineWidth;
    canvasContext.strokeStyle = strokeColor;
    canvasContext.lineCap = 'round'; // Set line cap to round for smoother edges
    canvasContext.stroke();
}

    </script>
</body>
</html>
